<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AWS on Grimoh</title><link>https://grimoh.com/tags/aws/</link><description>Recent content in AWS on Grimoh</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Sun, 06 Oct 2019 22:03:23 +0900</lastBuildDate><atom:link href="https://grimoh.com/tags/aws/index.xml" rel="self" type="application/rss+xml"/><item><title>Terraform backend の管理</title><link>https://grimoh.com/post/terraform-backend/</link><pubDate>Sun, 06 Oct 2019 22:03:23 +0900</pubDate><guid>https://grimoh.com/post/terraform-backend/</guid><description>Terraform backend について Terraform は、構成要素の状態を保存するために、tfstateファイルを生成します。Terraform では、このtfstateファイルとHCL(*.tf)で記述されたコードの内容に差分があれば、それに応じて、その差分のみを更新するように振る舞います。このtfstateファイルは、バージョン管理システム(e.g. Github)で保存することは良くないとされています。それは、以下の理由からです。
tfstateファイルの追従 以下のようなミスよって、期限切れのtfstateファイルで適用してしまう危険性がある バージョン管理システムへPushし忘れ local に最新のtfstateファイルを持ったままの状態 2人以上のメンバーが同じtfstateファイルで同時に実行することによる競合 バージョン管理システムの多くは、2人のメンバーが同じtfstateファイルで同時に実行することを防ぐロック(State Locking)を提供していない 秘匿情報 tfstateファイルはプレーンテキストで情報を保持するので、リソースの秘匿情報が記載されてしまう e.g. DBのパスワード 以上の問題から、backendリソースを使用して、tfstateファイルを外部のストレージに保存します。ここでは、AWSを使用するため、S3(tfstateファイルの保存、暗号化)+DynamoDB(State Locking)をbackendに指定します。S3のバケットはバージョニング設定ができるため、より安全な管理が行えます。Terraform backend の管理 Terraform backend は、terraform init時に必要となります。その為、Terraform で管理するには、AWS上に事前に作成しておき、Terraform にimportする方法が考えられます。また、外部ストレージとなるS3をTerraform で管理しているAWSアカウント上で管理することが考えられますが、公式では推奨していません。1後者については、別のAWSアカウントでTerraform backend を管理することが考えられますが、前者については、Terraform で管理すると、Terraform backend を管理するための Terraform の Terraform backend について考えなければならなくなり、堂々巡りに陥ってしまったので、CloudFormation を使用して管理することにしました。
grimoh/terraform-backend-setup-scripts
上記のスクリプトを使用すれば、CloudFormationスタック名、S3バケット名、DynamoDBテーブル名を指定することで、Terraform backend 用のS3、DynamoDBを作成することができます。
https://www.terraform.io/docs/backends/types/s3.html &amp;#x21a9;&amp;#xfe0e;</description></item></channel></rss>